;;; like-this -- Move to next thing like this -*- lexical-binding: t -*-
;;; Commentary:
;;    Move to next / previous thing like the thing at point. Here
;;    "thing" can be decided using font-lock faces or thing-at-pt
;;    library. Configure `like-this-try-list' for which faces and
;;    things are considered.

;;; Code:

(eval-when-compile
  (require 'subr-x))

(defvar like-this-try-list
  '((thing . region)
    (face . hi-yellow)
    (face . hi-pink)
    (face . hi-green)
    (face . hi-blue)
    (thing . email)
    (thing . symbol)
    (thing . word)
    (face . info-menu-header)
    (face . button))
  "Things to try look for.")

;; Remember the last thing we got, so successive calls do not
;; accidentally change what we search for.
(defvar like-this--last-match nil)

(defun like-this--fail-message (arg)
  (cond
   ((eq arg 1)
    (message "At last occurrence"))
   ((eq arg -1)
    (message "At first occurrence"))
   ('t
    (message "No %s %d occurrences"
             (if (> arg 0) "next" "previous") arg))))

;; Handle faces case
;; TODO: do this for text property in general.
(defun like-this--face-matches (face)
  "Returns true if face is active at point"
  (let ((f (get-text-property (point) 'face)))
    (cond ((not f) nil)
          ((symbolp f) (and (eq face f) face))
          ((listp f) (and (memq face f) face))
          (:else nil))))

(defun like-this--next-matching-face (face arg)
  "Move to next ARG-th place where the FACE matches"
  (dotimes (_ arg)
    (while (like-this--face-matches face)
      (if-let* ((c (next-single-property-change (point) 'face)))
          (goto-char c)
        (signal 'search-failed nil)))
    (while (not (like-this--face-matches face))
      (if-let* ((c (next-single-property-change (point) 'face)))
          (goto-char c)
        (signal 'search-failed nil)))))

(defun like-this--previous-matching-face (face arg)
  "Move to previous ARG-th place where the FACE matches"
  (dotimes (_ arg)
    (while (like-this--face-matches face)
      (if-let* ((c (previous-single-property-change (point) 'face)))
          (goto-char c)
        (signal 'search-failed nil)))
    (while (not (like-this--face-matches face))
      (if-let* ((c (previous-single-property-change (point) 'face)))
          (goto-char c)
        (signal 'search-failed nil)))))


;; TODO: handle failure
(defun like-this--next-face (face arg)
  (let ((saved-point (point)))
    (condition-case nil
        (if (> arg 0)
            (like-this--next-matching-face face arg)
          (like-this--previous-matching-face face (- arg)))
      (search-failed
       (like-this--fail-message arg)
       (goto-char saved-point)))))

;; Handle thing-at-point cases
(defun like-this--next-thing (match arg)
  "Search for next ARG'th occurrence of MATCH.

MATCH is the format generated by `like-this--find-match': (thing str
point-offset)."
  (let* ((thing (car match))
         (str (nth 1 match))
         (regexp (cond
                  ((eq thing 'symbol)
                   (isearch-symbol-regexp str))
                  ((eq thing 'word)
                   (word-search-regexp str))
                  ((eq thing 'region)
                   (regexp-quote str))
                  ('t
                   (concat "\\b" (regexp-quote str) "\\b"))))
         (p (nth 2 match))
         (l (length str))
         (offset (if (> arg 0) (- p l)
                   p))
         (saved-point (point)))
    (condition-case nil
        (progn
          (forward-char (- offset))
          (re-search-forward regexp nil nil arg)
          (forward-char offset))
      (search-failed
       (like-this--fail-message arg)
       (goto-char saved-point)))))

(defun like-this--find-match ()
  "Find a thing to search for.

For face, return (face . face-to-search)
pair. For thing, return (thing str pointer-offset) list."
  (seq-some
   (lambda (try-item)
     (let ((type (car try-item))
           (s (cdr try-item)))
       (cond ((eq type 'face)
              (if (like-this--face-matches s)
                  (list 'face s)))
             ((eq type 'thing)
              (if-let* ((bounds (bounds-of-thing-at-point s)))
                  (list s
                        (buffer-substring-no-properties (car bounds)
                                                        (cdr bounds))
                        (- (point) (car bounds))))))))
   like-this-try-list))

(defun string-or-symbol-name (x)
  (cond ((stringp x) x)
        ((symbolp x) (symbol-name x))))

;;;###autoload
(defun like-this-next (&optional arg match)
  "Navigate to ARG'th thing like this at point."
  (interactive "p")
  (unless match
    (if (and (memq last-command '(like-this-next like-this-prev))
             like-this--last-match)
        (setq match like-this--last-match)
      :else
      (setq match (like-this--find-match))
      (if match
          (message "%s %s like `%s'"
                   (if (> arg 0) "Next" "Prev")
                   (symbol-name (car match))
                   (string-or-symbol-name (cadr match)))
        :else
        (user-error "Not sure what to look for."))))
  (setq like-this--last-match match)
  (cond ((eq (car match) 'face)
         (like-this--next-face (cadr match) arg))
        (:else                      ; other cases are things
         (like-this--next-thing match arg))))

;;;###autoload
(defun like-this-prev (&optional arg match)
  "Navigate to previous ARG'th thing like this at point."
  (interactive "p")
  (like-this-next (- arg) match))

(provide 'like-this)
;;; like-this.el ends here
