;;; like-this -- Move to next thing like this -*- lexical-binding: t -*-
;;; Commentary:
;;    Move to next / previous thing like the thing at point. Here
;;    "thing" can be decided using font-lock faces or thing-at-pt
;;    library. Configure `like-this-try-alist' for which faces and
;;    things are considered.

;;; Code:

(eval-when-compile
  (require 'subr-x))

(defvar like-this-try-alist
  '((thing . region)
    (face . hi-yellow)
    (face . hi-pink)
    (face . hi-green)
    (face . hi-blue)
    (thing . email)
    (thing . symbol)
    (thing . word)
    (face . info-menu-header)
    (face . button))
  "Things to try look for.")

;; Remember the last thing we got, so successive calls do not
;; accidentally change what we search for.
(defvar like-this--last-match nil)

(cl-defgeneric like-this-try-match (matcher)
  "Try to match an item in `like-this-try-alist'.")

(cl-defgeneric like-this-next-match (match arg)
  "Search for next ARG-th MATCH.")

(cl-defgeneric like-this-match-name (match)
  "Short name for a match for messages.")

;;; Face case
;; TODO: do this for text property in general.
(defun like-this--face-matches (face)
  "Returns true if face is active at point"
  (let ((f (get-text-property (point) 'face)))
    (cond ((not f) nil)
          ((symbolp f) (and (eq face f) face))
          ((listp f) (and (memq face f) face))
          (:else nil))))

(defun like-this--next-matching-face (face arg)
  "Move to next ARG-th place where the FACE matches"
  (dotimes (_ arg)
    (while (like-this--face-matches face)
      (if-let* ((c (next-single-property-change (point) 'face)))
          (goto-char c)
        (signal 'search-failed nil)))
    (while (not (like-this--face-matches face))
      (if-let* ((c (next-single-property-change (point) 'face)))
          (goto-char c)
        (signal 'search-failed nil)))))

(defun like-this--previous-matching-face (face arg)
  "Move to previous ARG-th place where the FACE matches"
  (dotimes (_ arg)
    (while (like-this--face-matches face)
      (if-let* ((c (previous-single-property-change (point) 'face)))
          (goto-char c)
        (signal 'search-failed nil)))
    (while (not (like-this--face-matches face))
      (if-let* ((c (previous-single-property-change (point) 'face)))
          (goto-char c)
        (signal 'search-failed nil)))))

(cl-defmethod like-this-try-match ((matcher (head face)))
  "Handle (face . button) type of cases."
  (let ((s (cdr matcher)))
    (if (like-this--face-matches s)
        (list 'face s))))

(cl-defmethod like-this-match-name ((match (head face)))
  ;; maybe use `query-replace-descr'.
  (format "face `%s'" (symbol-name (cadr match))))

(cl-defmethod like-this-next-match ((match (head face)) arg)
  (let ((face (cadr match)))
    (if (> arg 0)
        (like-this--next-matching-face face arg)
      (like-this--previous-matching-face face (- arg)))))


;;; Thing case
(cl-defmethod like-this-try-match ((matcher (head thing)))
  "Handle (thing . symbol) type of cases using thing-at-point."
  (if-let* ((bounds (bounds-of-thing-at-point (cdr matcher))))
      (list 'thing
            (cdr matcher)
            (buffer-substring-no-properties (car bounds)
                                            (cdr bounds))
            (- (point) (car bounds)))))

(cl-defmethod like-this-match-name ((match (head thing)))
  (format "%s `%s'" (cadr match) (caddr match)))

(cl-defmethod like-this-next-match ((match (head thing)) arg)
  "Search for next ARG'th occurrence of MATCH.

MATCH is the format generated by `like-this-try-match': (thing str
point-offset)."
  (let* ((thing (cadr match))
         (str (nth 2 match))
         (regexp (cond
                  ((eq thing 'symbol)
                   (isearch-symbol-regexp str))
                  ((eq thing 'word)
                   (word-search-regexp str))
                  (:else
                   (regexp-quote str))))
         (p (nth 3 match))
         (l (length str))
         (offset (if (> arg 0) (- p l)
                   p)))
          (forward-char (- offset))
          (re-search-forward regexp nil nil arg)
          (forward-char offset)))

(defun like-this--fail-message (arg match)
  (let ((n (like-this-match-name match)))
    (cond
     ((eq arg 1)
      (message "At last %s" n))
     ((eq arg -1)
      (message "At first %s" n))
     (:else
      (message "No %s %d %s"
               (if (> arg 0) "next" "previous") arg n)))))

;;;###autoload
(defun like-this-next (&optional arg match)
  "Navigate to ARG'th thing like this at point.

With universal arg, look for the previous match."
  (interactive "p")
  (let (show-message
        (universal-arg (and (listp current-prefix-arg)
                            (numberp (car current-prefix-arg)))))
    (if universal-arg
        (setq arg (if (> arg 0) 1 -1)))
    (cond (match
           (setq like-this--last-match match))
          ((and like-this--last-match
                (memq last-command '(like-this-next like-this-prev)))
           (setq match like-this--last-match))
          ((and like-this--last-match universal-arg)
           (setq match like-this--last-match)
           (setq show-message 't))
          ((setq match (seq-some
                        'like-this-try-match
                        like-this-try-alist))
           (setq like-this--last-match match)
           (setq show-message 't))
          (:else
           (user-error "Nothing to look for.")))

    (let ((saved-point (point)))
      (condition-case nil
          (progn
            (like-this-next-match match arg)
            (if show-message
                (message "%s %s"
                         (if (> arg 0) "Next" "Previous")
                         (like-this-match-name match))))
        (search-failed
         (like-this--fail-message arg match)
         (goto-char saved-point))))))

;;;###autoload
(defun like-this-prev (&optional arg match)
  "Navigate to previous ARG'th thing like this at point."
  (interactive "p")
  (like-this-next (- arg) match))

(provide 'like-this)
;;; like-this.el ends here
