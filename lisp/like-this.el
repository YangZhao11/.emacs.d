;;; like-this -- Move to next thing like this -*- lexical-binding: t -*-
;;; Commentary:
;;    Move to next / previous thing like the thing at point. Here
;;    "thing" can be decided using font-lock faces or thing-at-pt
;;    library. Configure `like-this-try-alist' for which faces and
;;    things are considered.

;;; Code:

(eval-when-compile
  (require 'subr-x))

(defvar like-this-try-alist
  '((thing . region)
    (face . hi-yellow)
    (face . hi-pink)
    (face . hi-green)
    (face . hi-blue)
    (button)
    (thing . email)
    (thing . symbol)
    (thing . word)
    (face . info-menu-header))
  "Things to try look for.")

(cl-defgeneric like-this-try-match (matcher)
  "Try to match an item in `like-this-try-alist'.")

(cl-defgeneric like-this-next-match (match arg)
  "Search for next ARG-th MATCH.
MATCH is returned from `like-this-try-match'.")

(cl-defgeneric like-this-match-name (match)
  "Short name for a MATCH for messages.")

;; Remember the last thing we got, so successive calls do not
;; accidentally change what we search for.
(defvar like-this--last-match nil)

;;; Util functions for properties
(defun like-this--prop-value (prop &optional extractor &rest args)
  "Returns property value for PROP.

If EXTRACTOR is a function, call it with the property value as first argument, and ARGS as the rest arguments."
  (let ((v (get-char-property (point) prop)))
    (if (and v extractor)
        (if args
            (apply extractor v args)
          (funcall extractor v))
      v)))

(defun like-this--next-matching-prop
    (prop value n &optional extractor &rest args)
  "Move to next N-th place where the PROP matches value"
  (dotimes (_ n)
    (while (eq (apply 'like-this--prop-value prop extractor args) value)
      (let* ((p (point))
             (c (next-single-char-property-change p prop)))
        (if (< p c)
            (goto-char c)
          (signal 'search-failed nil))))
    (while (not (eq (apply 'like-this--prop-value prop extractor args) value))
      (let* ((p (point))
             (c (next-single-char-property-change p prop)))
        (if (< p c)
            (goto-char c)
          (signal 'search-failed nil))))))

(defun like-this--previous-matching-prop
    (prop value n &optional extractor &rest args)
  "Move to previous ARG-th place where the FACE matches"
  (dotimes (_ n)
    (while (eq (apply 'like-this--prop-value prop extractor args) value)
      (let* ((p (point))
             (c (previous-single-char-property-change p prop)))
        (if (< c p)
            (goto-char c)
          (signal 'search-failed nil))))
    (while (not (eq (apply 'like-this--prop-value prop extractor args) value))
      (let* ((p (point))
             (c (previous-single-char-property-change p prop)))
        (if (< c p)
            (goto-char c)
          (signal 'search-failed nil))))))

;;; Button by button-type
(cl-defmethod like-this-try-match ((matcher (head button)))
  (if-let* ((button-type (like-this--prop-value 'button #'car)))
      (list 'button button-type)))

(cl-defmethod like-this-match-name ((match (head button)))
  (format "button type %s" (symbol-name (cadr match))))

(cl-defmethod like-this-next-match ((match (head button)) arg)
  (let ((button-type (cadr match)))
    (if (> arg 0)
        (like-this--next-matching-prop
         'button button-type arg #'car)
      (like-this--previous-matching-prop
       'button button-type (- arg) #'car))))

;;; Face case
(defun like-this--face-extractor (prop-value face)
  (cond ((not prop-value) nil)
        ((symbolp prop-value) (and (eq face prop-value) face))
        ((listp prop-value) (and (memq face prop-value) face))))

(cl-defmethod like-this-try-match ((matcher (head face)))
  "Handle (face . button) type of cases."
  (let ((s (cdr matcher)))
    (if (like-this--prop-value 'face #'like-this--face-extractor s)
        (list 'face s))))

(cl-defmethod like-this-match-name ((match (head face)))
  ;; maybe use `query-replace-descr'.
  (format "face ‘%s’" (symbol-name (cadr match))))

(cl-defmethod like-this-next-match ((match (head face)) arg)
  (let ((face (cadr match)))
    (if (> arg 0)
        (like-this--next-matching-prop
         'face face arg #'like-this--face-extractor face)
      (like-this--previous-matching-prop
       'face face (- arg) #'like-this--face-extractor face))))


;;; Thing case
(cl-defmethod like-this-try-match ((matcher (head thing)))
  "Handle (thing . symbol) type of cases using thing-at-point."
  (if-let* ((bounds (bounds-of-thing-at-point (cdr matcher))))
      (list 'thing
            (cdr matcher)
            (buffer-substring-no-properties (car bounds)
                                            (cdr bounds))
            (- (point) (car bounds)))))

(cl-defmethod like-this-match-name ((match (head thing)))
  (format "%s ‘%s’" (cadr match) (caddr match)))

(cl-defmethod like-this-next-match ((match (head thing)) arg)
  "Search for next ARG'th occurrence of MATCH.

MATCH is the format generated by `like-this-try-match': (thing str
point-offset)."
  (let* ((thing (cadr match))
         (str (nth 2 match))
         (regexp (cond
                  ((eq thing 'symbol)
                   (isearch-symbol-regexp str))
                  ((eq thing 'word)
                   (word-search-regexp str))
                  (:else
                   (regexp-quote str))))
         (p (nth 3 match))
         (l (length str))
         (offset (if (> arg 0) (- p l)
                   p)))
          (forward-char (- offset))
          (re-search-forward regexp nil nil arg)
          (forward-char offset)))

(defun like-this--fail-message (arg match)
  (let ((n (like-this-match-name match)))
    (cond
     ((eq arg 1)
      (message "At last %s" n))
     ((eq arg -1)
      (message "At first %s" n))
     (:else
      (message "No %s %d %s"
               (if (> arg 0) "next" "previous") arg n)))))

;;;###autoload
(defun like-this-next (&optional arg match)
  "Navigate to ARG'th thing like this at point.

With universal arg, look for the previous match."
  (interactive "p")
  (let (show-message
        (universal-arg (and (listp current-prefix-arg)
                            (numberp (car current-prefix-arg)))))
    (if universal-arg
        (setq arg (if (> arg 0) 1 -1)))
    (cond (match
           (setq like-this--last-match match))
          ((and like-this--last-match
                (memq last-command '(like-this-next like-this-prev)))
           (setq match like-this--last-match))
          ((and like-this--last-match universal-arg)
           (setq match like-this--last-match)
           (setq show-message 't))
          ((setq match (seq-some
                        'like-this-try-match
                        like-this-try-alist))
           (setq like-this--last-match match)
           (setq show-message 't))
          (:else
           (setq like-this--last-match nil)
           (user-error "Nothing to look for.")))

    (let ((saved-point (point)))
      (condition-case nil
          (progn
            (like-this-next-match match arg)
            (if show-message
                (message "%s %s"
                         (if (> arg 0) "Next" "Previous")
                         (like-this-match-name match))))
        (search-failed
         (like-this--fail-message arg match)
         (goto-char saved-point))))))

;;;###autoload
(defun like-this-prev (&optional arg match)
  "Navigate to previous ARG'th thing like this at point."
  (interactive "p")
  (like-this-next (- arg) match))

(provide 'like-this)
;;; like-this.el ends here
